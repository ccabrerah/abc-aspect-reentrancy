package abc.aspectj.parse;

import java.util.*;
import java_cup.runtime.*;
import polyglot.ast.*;
import polyglot.lex.*;
import polyglot.util.*;
import polyglot.parse.*;
import polyglot.types.*;
import polyglot.*;
import polyglot.ast.Assert;
import abc.aspectj.types.AspectJTypeSystem;
import abc.aspectj.ast.AspectJNodeFactory;
import polyglot.ext.jl.parse.Name;
import abc.aspectj.ast.*;

parser Grm extends polyglot.ext.jl.parse.Grm {:

    public final AspectJTypeSystem ts;
    public final AspectJNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (AspectJTypeSystem) t;
        nf = (AspectJNodeFactory) n;
    }

    /* Flag for personalized parser trace. */
    public static boolean parserTraceOn = false;

    public static void parserTrace (String s)
      { if (parserTraceOn) 
          System.err.println(" REDUCED: " + s); 
      }

    /**
     * Override the default Polyglot routine
     */	

    public void report_fatal_error (String message, Object info)
    throws Exception
    {
       report_error (message, info);
       die ();
    }



:}
scan with {: return nextSymbol(); :};
terminal Token BOOLEAN;
terminal Token BYTE, SHORT, INT, LONG, CHAR;
terminal Token FLOAT, DOUBLE;
terminal Token LBRACK, RBRACK;
terminal Identifier IDENTIFIER;
terminal Token DOT;
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ;
terminal Token LPAREN, RPAREN, COLON;
terminal Token PACKAGE;
terminal Token IMPORT;
terminal Token PUBLIC, PROTECTED, PRIVATE;
terminal Token STATIC;
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS;
terminal Token EXTENDS;
terminal Token IMPLEMENTS;
terminal Token VOID;
terminal Token THROWS;
terminal Token THIS, SUPER;
terminal Token INTERFACE;
terminal Token IF, ELSE;
terminal Token SWITCH;
terminal Token CASE, DEFAULT;
terminal Token DO, WHILE;
terminal Token FOR;
terminal Token BREAK;
terminal Token CONTINUE;
terminal Token RETURN;
terminal Token THROW;
terminal Token TRY;
terminal Token CATCH;
terminal Token FINALLY;
terminal Token NEW;
terminal Token PLUSPLUS;
terminal Token MINUSMINUS;
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT;
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF;
terminal Token EQEQ, NOTEQ;
terminal Token AND;
terminal Token XOR;
terminal Token OR;
terminal Token ANDAND;
terminal Token OROR;
terminal Token QUESTION;
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ;
terminal Token ANDEQ, XOREQ, OREQ;
terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL;
terminal polyglot.lex.LongLiteral LONG_LITERAL;
terminal polyglot.lex.DoubleLiteral DOUBLE_LITERAL;
terminal polyglot.lex.FloatLiteral FLOAT_LITERAL;
terminal polyglot.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal polyglot.lex.CharacterLiteral CHARACTER_LITERAL;
terminal polyglot.lex.StringLiteral STRING_LITERAL;
terminal polyglot.lex.NullLiteral NULL_LITERAL;
terminal Token STRICTFP;
terminal Token ASSERT;
terminal CONST, GOTO;
non terminal SourceFile goal;
non terminal polyglot.ast.Lit literal;
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode class_type, interface_type;
non terminal TypeNode array_type;
non terminal Name name, simple_name, qualified_name;
non terminal SourceFile compilation_unit;
non terminal PackageNode package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal Import import_declaration;
non terminal Import single_type_import_declaration;
non terminal Import type_import_on_demand_declaration;
non terminal ClassDecl type_declaration;
non terminal Flags modifiers_opt, modifiers, modifier;
non terminal ClassDecl class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal ClassBody class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal List class_body_declaration, class_member_declaration;
non terminal List field_declaration;
non terminal List variable_declarators;
non terminal VarDeclarator variable_declarator;
non terminal VarDeclarator variable_declarator_id;
non terminal Expr variable_initializer;
non terminal MethodDecl method_declaration, method_header;
non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal Formal formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;
non terminal Block method_body;
non terminal Block static_initializer;
non terminal ConstructorDecl constructor_declaration;
non terminal Block constructor_body;
non terminal ConstructorCall explicit_constructor_invocation;
non terminal ClassDecl interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal ClassBody interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal List interface_member_declaration;
non terminal List constant_declaration;
non terminal MethodDecl abstract_method_declaration;
non terminal ArrayInit array_initializer;
non terminal List variable_initializers;
non terminal Block block;
non terminal List block_statements_opt, block_statements;
non terminal List block_statement;
non terminal List local_variable_declaration_statement;
non terminal List local_variable_declaration;
non terminal Stmt statement, statement_no_short_if;
non terminal Stmt statement_without_trailing_substatement;
non terminal Empty empty_statement;
non terminal Labeled labeled_statement, labeled_statement_no_short_if;
non terminal Stmt expression_statement;
non terminal Expr statement_expression;
non terminal If if_then_statement;
non terminal If if_then_else_statement, if_then_else_statement_no_short_if;
non terminal Switch switch_statement;
non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;
non terminal Case switch_label;
non terminal While while_statement, while_statement_no_short_if;
non terminal Do do_statement;
non terminal For for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal Name identifier_opt;
non terminal Branch break_statement, continue_statement;
non terminal Return return_statement;
non terminal Throw throw_statement;
non terminal Synchronized synchronized_statement;
non terminal Try try_statement;
non terminal List catches_opt, catches;
non terminal Catch catch_clause;
non terminal Block finally;
non terminal Assert assert_statement;
non terminal Expr primary, primary_no_new_array;
non terminal Expr class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal NewArray array_creation_expression;
non terminal List dim_exprs;
non terminal Expr dim_expr;
non terminal Integer dims_opt, dims;
non terminal Field field_access;
non terminal Call method_invocation;
non terminal ArrayAccess array_access;
non terminal Expr postfix_expression;
non terminal Unary postincrement_expression, postdecrement_expression;
non terminal Expr unary_expression, unary_expression_not_plus_minus;
non terminal Unary preincrement_expression, predecrement_expression;
non terminal Cast cast_expression;
non terminal Expr multiplicative_expression, additive_expression;
non terminal Expr shift_expression, relational_expression, equality_expression;
non terminal Expr and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expr conditional_and_expression, conditional_or_expression;
non terminal Expr conditional_expression, assignment_expression;
non terminal Expr assignment;
non terminal Expr left_hand_side;
non terminal Assign.Operator assignment_operator;
non terminal Expr expression_opt, expression;
non terminal Expr constant_expression;
terminal Token ASPECT;
terminal Token PRIVILEGED;
terminal Token AFTER;
terminal Token AROUND;
terminal Token BEFORE;
terminal Token DECLARE;
terminal Token ISSINGLETON;
terminal Token PERCFLOW;
terminal Token PERCFLOWBELOW;
terminal Token PERTARGET;
terminal Token PERTHIS;
terminal Token POINTCUT;
terminal Token PROCEED;
terminal Token THISENCLOSINGJOINPOINTSTATICPART;
terminal Token THISJOINPOINT;
terminal Token THISJOINPOINTSTATICPART;
terminal Token PC_ADVICEEXECUTION;
terminal Token PC_ARGS;
terminal Token PC_CALL;
terminal Token PC_CFLOW;
terminal Token PC_CFLOWBELOW;
terminal Token PC_ERROR;
terminal Token PC_EXECUTION;
terminal Token PC_GET;
terminal Token PC_HANDLER;
terminal Token PC_IF;
terminal Token PC_INITIALIZATION;
terminal Token PC_PARENTS;
terminal Token PC_PRECEDENCE;
terminal Token PC_PREINITIALIZATION;
terminal Token PC_RETURNING;
terminal Token PC_SET;
terminal Token PC_SOFT;
terminal Token PC_STATICINITIALIZATION;
terminal Token PC_TARGET;
terminal Token PC_THIS;
terminal Token PC_THROWING;
terminal Token PC_WARNING;
terminal Token PC_WITHIN;
terminal Token PC_WITHINCODE;
terminal Token PC_DOTDOT;
terminal Token PC_NOT;
terminal Token PC_ANDAND;
terminal Token PC_OROR;
terminal Token PC_PLUS;
terminal Token PC_MULT;
terminal Identifier IDENTIFIERPATTERN;
non terminal AspectDecl aspect_declaration;
non terminal PerClause perclause_opt;
non terminal PerClause perclause;
non terminal AspectBody aspect_body;
non terminal List aspect_body_declarations;
non terminal List aspect_body_declaration;
non terminal DeclareDecl declare_declaration;
non terminal PointcutDecl pointcut_declaration;
non terminal AdviceDecl advice_declaration;
non terminal AdviceSpec advice_spec;
non terminal IntertypeDecl intertype_member_declaration;
non terminal Pointcut pointcut_expr;
non terminal Pointcut _pointcut_expr;
non terminal Pointcut unary_pointcut_expr;
non terminal Pointcut basic_pointcut_expr;
non terminal NamePattern name_pattern;
non terminal SimpleNamePattern simple_name_pattern;
non terminal Token aspectj_reserved_identifier;
non terminal TypePatternExpr type_pattern_expr;
non terminal TypePatternExpr or_type_pattern_expr;
non terminal TypePatternExpr unary_type_pattern_expr;
non terminal TypePatternExpr basic_type_pattern;
non terminal TypePatternExpr base_type_pattern;
non terminal List classname_pattern_expr_list;
non terminal ClassnamePatternExpr classname_pattern_expr;
non terminal ClassnamePatternExpr or_classname_pattern_expr;
non terminal ClassnamePatternExpr unary_classname_pattern_expr;
non terminal ClassnamePatternExpr basic_classname_pattern;
non terminal List modifier_pattern_expr;
non terminal ClassnamePatternExpr throws_pattern_expr_opt;
non terminal MethodConstructorPattern method_constructor_pattern;
non terminal MethodPattern method_pattern;
non terminal ConstructorPattern constructor_pattern;
non terminal FieldPattern field_pattern;
non terminal ClassTypeDotNew classtype_dot_new;
non terminal ClassTypeDotId classtype_dot_id;
non terminal List formal_pattern_list_opt;
non terminal List formal_pattern_list;
non terminal FormalPattern formal_pattern;
non terminal List type_id_star_list_opt;
non terminal List type_id_star_list;
non terminal ArgPattern type_id_star;


start with goal;

goal ::=
    compilation_unit:a {:  RESULT = a;  :};

literal ::=
    INTEGER_LITERAL:a {:
                      RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue()); 
                      :}
 |  LONG_LITERAL:a {:
                   RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                     a.getValue().longValue()); 
                   :}
 |  DOUBLE_LITERAL:a {:
                     RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.DOUBLE,
                                           a.getValue().doubleValue()); 
                     :}
 |  FLOAT_LITERAL:a {:
                    RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.FLOAT,
                                           a.getValue().floatValue()); 
                    :}
 |  BOOLEAN_LITERAL:a {:
                      RESULT = parser.nf.BooleanLit(parser.pos(a),
                                         a.getValue().booleanValue()); 
                      :}
 |  CHARACTER_LITERAL:a {:
                        RESULT = parser.nf.CharLit(parser.pos(a),
                      a.getValue().charValue()); 
                        :}
 |  STRING_LITERAL:a {:
                     RESULT = parser.nf.StringLit(parser.pos(a), a.getValue()); 
                     :}
 |  NULL_LITERAL:a {:  RESULT = parser.nf.NullLit(parser.pos(a));  :};

type ::=
    primitive_type:a {:  RESULT = a;  :}
 |  reference_type:a {:  RESULT = a;  :};

primitive_type ::=
    numeric_type:a {:  RESULT = a;  :}
 |  BOOLEAN:a {:
              RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean()); 
              :};

numeric_type ::=
    integral_type:a {:  RESULT = a;  :}
 |  floating_point_type:a {:  RESULT = a;  :};

integral_type ::=
    BYTE:a {:
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Byte()); 
           :}
 |  CHAR:a {:
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Char()); 
           :}
 |  SHORT:a {:
            RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Short()); 
            :}
 |  INT:a {:
          RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Int()); 
          :}
 |  LONG:a {:
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Long()); 
           :};

floating_point_type ::=
    FLOAT:a {:
            RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Float()); 
            :}
 |  DOUBLE:a {:
             RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Double()); 
             :};

reference_type ::=
    class_or_interface_type:a {:  RESULT = a;  :}
 |  array_type:a {:  RESULT = a;  :};

class_or_interface_type ::=
    name:a {:  RESULT = a.toType();  :};

class_type ::=
    class_or_interface_type:a {:  RESULT = a;  :};

interface_type ::=
    class_or_interface_type:a {:  RESULT = a;  :};

array_type ::=
    primitive_type:a dims:b {:
                            RESULT = parser.array(a, b.intValue()); 
                            :}
 |  name:a dims:b {:
                  RESULT = parser.array(a.toType(), b.intValue()); 
                  :};

name ::=
    simple_name:a {:  RESULT = a;  :}
 |  qualified_name:a {:  RESULT = a;  :};

simple_name ::=
    IDENTIFIER:a {:
                 RESULT = new Name(parser, parser.pos(a), a.getIdentifier()); 
                 :}
 |  THISJOINPOINT:a {:
                    RESULT = new Name(parser, parser.pos(a), "thisJoinPoint"); 
       
                    :}
 |  THISJOINPOINTSTATICPART:a {:
                              RESULT = new Name(parser, parser.pos(a), "thisJoinPointStaticPart"); 
       
                              :}
 |  THISENCLOSINGJOINPOINTSTATICPART:a {:
                                       RESULT = new Name(parser, parser.pos(a), 
                                "thisEnclosingJoinPointStaticPart"); 
       
                                       :};

qualified_name ::=
    name:a DOT IDENTIFIER:b {:
                            RESULT = new Name(parser, parser.pos(a, b), a, b.getIdentifier()); 
                            :};

compilation_unit ::=
    package_declaration_opt:a import_declarations_opt:b type_declarations_opt:c {:
                                                                                RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()),
					     a, b, c);
	    
                                                                                :};

package_declaration_opt ::=
    package_declaration:a {:  RESULT = a;  :}
 |  {:  RESULT = null;  :};

import_declarations_opt ::=
    import_declarations:a {:  RESULT = a;  :}
 |  {:
    RESULT = new TypedList(new LinkedList(), Import.class, false); 
    :};

type_declarations_opt ::=
    type_declarations:a {:  RESULT = a;  :}
 |  {:
    RESULT = new TypedList(new LinkedList(), ClassDecl.class, false); 
    :};

import_declarations ::=
    import_declaration:a {:
                         List l = new TypedList(new LinkedList(), Import.class, false); 
               l.add(a);
               RESULT = l; 
                         :}
 |  import_declarations:a import_declaration:b {:
                                               RESULT = a; 
               a.add(b); 
                                               :};

type_declarations ::=
    type_declaration:a {:
                       List l = new TypedList(new LinkedList(), ClassDecl.class, false); 
               if (a != null)
                   l.add(a);
               RESULT = l; 
                       :}
 |  type_declarations:a type_declaration:b {:
                                           RESULT = a;
               if (b != null)
                   a.add(b); 
                                           :};

package_declaration ::=
    PACKAGE name:a SEMICOLON {:  RESULT = a.toPackage();  :};

import_declaration ::=
    single_type_import_declaration:a {:  RESULT = a;  :}
 |  type_import_on_demand_declaration:a {:  RESULT = a;  :};

single_type_import_declaration ::=
    IMPORT:a name:b SEMICOLON:c {:
                                RESULT = parser.nf.Import(parser.pos(a, c), Import.CLASS, b.toString()); 
                                :};

type_import_on_demand_declaration ::=
    IMPORT:a name:b DOT MULT SEMICOLON:c {:
                                         RESULT = parser.nf.Import(parser.pos(a, c), Import.PACKAGE, b.toString()); 
                                         :};

type_declaration ::=
    class_declaration:a {:  RESULT = a;  :}
 |  interface_declaration:a {:  RESULT = a;  :}
 |  SEMICOLON {:  RESULT = null;  :}
 |  aspect_declaration:a {:  RESULT = a;  :};

modifiers_opt ::=
    {:  RESULT = Flags.NONE;  :}
 |  modifiers:a {:  RESULT = a;  :};

modifiers ::=
    modifier:a {:  RESULT = a;  :}
 |  modifiers:a modifier:b {:
                           if (a.intersects(b)) parser.die(parser.position());
               RESULT = a.set(b); 
                           :};

modifier ::=
    PUBLIC:a {:  RESULT = Flags.PUBLIC;  :}
 |  PROTECTED:a {:  RESULT = Flags.PROTECTED;  :}
 |  PRIVATE:a {:  RESULT = Flags.PRIVATE;  :}
 |  STATIC:a {:  RESULT = Flags.STATIC;  :}
 |  ABSTRACT:a {:  RESULT = Flags.ABSTRACT;  :}
 |  FINAL:a {:  RESULT = Flags.FINAL;  :}
 |  NATIVE:a {:  RESULT = Flags.NATIVE;  :}
 |  SYNCHRONIZED:a {:  RESULT = Flags.SYNCHRONIZED;  :}
 |  TRANSIENT:a {:  RESULT = Flags.TRANSIENT;  :}
 |  VOLATILE:a {:  RESULT = Flags.VOLATILE;  :}
 |  STRICTFP:a {:  RESULT = Flags.STRICTFP;  :};

class_declaration ::=
    modifiers_opt:a CLASS:n IDENTIFIER:b super_opt:c interfaces_opt:d class_body:e {:
                                                                                   RESULT = parser.nf.ClassDecl(parser.pos(n, e),
                a, b.getIdentifier(), c, d, e); 
                                                                                   :};

super ::=
    EXTENDS class_type:a {:  RESULT = a;  :};

super_opt ::=
   
 |  super:a {:  RESULT = a;  :};

interfaces ::=
    IMPLEMENTS interface_type_list:a {:  RESULT = a;  :};

interfaces_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    :}
 |  interfaces:a {:  RESULT = a;  :};

interface_type_list ::=
    interface_type:a {:
                     List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; 
                     :}
 |  interface_type_list:a COMMA interface_type:b {:
                                                 RESULT = a;
               a.add(b); 
                                                 :};

class_body ::=
    LBRACE:n class_body_declarations_opt:a RBRACE:b {:
                                                    RESULT = parser.nf.ClassBody(parser.pos(n, b), a); 
                                                    :};

class_body_declarations_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    :}
 |  class_body_declarations:a {:  RESULT = a;  :};

class_body_declarations ::=
    class_body_declaration:a {:  RESULT = a;  :}
 |  class_body_declarations:a class_body_declaration:b {:
                                                       RESULT = a;
               a.addAll(b); 
                                                       :};

class_body_declaration ::=
    class_member_declaration:a {:  RESULT = a;  :}
 |  static_initializer:a {:
                         List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.STATIC, a));
               RESULT = l; 
                         :}
 |  constructor_declaration:a {:
                              List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                              :}
 |  block:a {:
            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.NONE, a));
               RESULT = l; 
            :}
 |  SEMICOLON {:  RESULT = Collections.EMPTY_LIST;  :};

class_member_declaration ::=
    field_declaration:a {:  RESULT = a;  :}
 |  method_declaration:a {:
                         List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                         :}
 |  modifiers_opt:a CLASS:n IDENTIFIER:b super_opt:c interfaces_opt:d class_body:e {:
                                                                                   List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.ClassDecl(parser.pos(n, e),
                        a, b.getIdentifier(), c, d, e));
               RESULT = l; 
                                                                                   :}
 |  interface_declaration:a {:
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                            :}
 |  aspect_declaration:a {:
                         Grm.parserTrace("a class member declaration is an aspect");
       List l = new TypedList(new LinkedList(),
                              ClassMember.class,
                              false);
       l.add(a);
       RESULT = l;
    
                         :}
 |  pointcut_declaration:a {:
                           Grm.parserTrace("a class member declaration is a pointcut declaration");
       List l = new TypedList(new LinkedList(),
                              ClassMember.class,
                              false);
       l.add(a);
       RESULT = l;
    
                           :};

field_declaration ::=
    modifiers_opt:a type:b variable_declarators:c SEMICOLON:e {:
                                                              List l = new TypedList(new LinkedList(), ClassMember.class, false);
               for (Iterator i = c.iterator(); i.hasNext(); ) {
                   VarDeclarator d = (VarDeclarator) i.next();
                   l.add(parser.nf.FieldDecl(parser.pos(b, e),
                                             a, parser.array(b, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; 
                                                              :};

variable_declarators ::=
    variable_declarator:a {:
                          List l = new TypedList(new LinkedList(), VarDeclarator.class, false);
               l.add(a);
               RESULT = l; 
                          :}
 |  variable_declarators:a COMMA variable_declarator:b {:
                                                       RESULT = a;
               a.add(b); 
                                                       :};

variable_declarator ::=
    variable_declarator_id:a {:  RESULT = a;  :}
 |  variable_declarator_id:a EQ variable_initializer:b {:
                                                       RESULT = a;
               a.init = b; 
                                                       :};

variable_declarator_id ::=
    IDENTIFIER:a {:
                 RESULT = new VarDeclarator(parser.pos(a),
                            a.getIdentifier()); 
                 :}
 |  variable_declarator_id:a LBRACK RBRACK {:
                                           RESULT = a;
               a.dims++; 
                                           :};

variable_initializer ::=
    expression:a {:  RESULT = a;  :}
 |  array_initializer:a {:  RESULT = a;  :};

method_declaration ::=
    method_header:a method_body:b {:
                                  RESULT = (MethodDecl) a.body(b); 
                                  :};

method_header ::=
    modifiers_opt:a type:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN:g dims_opt:e throws_opt:f {:
                                                                                                            RESULT = parser.nf.MethodDecl(parser.pos(b, g, c), a,
                parser.array(b, e.intValue()), c.getIdentifier(),
                d, f, null); 
                                                                                                            :}
 |  modifiers_opt:a VOID:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN:g throws_opt:f {:
                                                                                                 RESULT = parser.nf.MethodDecl(parser.pos(b, g, c), a,
                parser.nf.CanonicalTypeNode(parser.pos(b),
                parser.ts.Void()), c.getIdentifier(), d, f, null); 
                                                                                                 :};

formal_parameter_list_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), Formal.class, false); 
    :}
 |  formal_parameter_list:a {:  RESULT = a;  :};

formal_parameter_list ::=
    formal_parameter:a {:
                       List l = new TypedList(new LinkedList(), Formal.class, false);
               l.add(a);
               RESULT = l; 
                       :}
 |  formal_parameter_list:a COMMA formal_parameter:b {:
                                                     RESULT = a;
               a.add(b); 
                                                     :};

formal_parameter ::=
    type:a variable_declarator_id:b {:
                                    RESULT = parser.nf.Formal(parser.pos(a, b, b), Flags.NONE,
                                         parser.array(a, b.dims), b.name); 
                                    :}
 |  FINAL type:a variable_declarator_id:b {:
                                          RESULT = parser.nf.Formal(parser.pos(a, b, b), Flags.FINAL,
                     parser.array(a, b.dims), b.name); 
                                          :};

throws_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    :}
 |  throws:a {:  RESULT = a;  :};

throws ::=
    THROWS class_type_list:a {:  RESULT = a;  :};

class_type_list ::=
    class_type:a {:
                 List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; 
                 :}
 |  class_type_list:a COMMA class_type:b {:
                                         RESULT = a;
               a.add(b); 
                                         :};

method_body ::=
    block:a {:  RESULT = a;  :}
 |  SEMICOLON {:  RESULT = null;  :};

static_initializer ::=
    STATIC block:a {:  RESULT = a;  :};

constructor_declaration ::=
    modifiers_opt:m simple_name:a LPAREN formal_parameter_list_opt:b RPAREN throws_opt:c constructor_body:d {:
                                                                                                            RESULT = parser.nf.ConstructorDecl(parser.pos(a, d), m, a.toString(), b,
                c, d); 
                                                                                                            :};

constructor_body ::=
    LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE:d {:
                                                                           List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               l.addAll(b);
               RESULT = parser.nf.Block(parser.pos(n, d), l); 
                                                                           :}
 |  LBRACE:n explicit_constructor_invocation:a RBRACE:d {:
                                                        RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                                        :}
 |  LBRACE:n block_statements:a RBRACE:d {:
                                         a.add(0, parser.nf.SuperCall(parser.pos(n, d), 
                Collections.EMPTY_LIST));
               RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                         :}
 |  LBRACE:n RBRACE:d {:
                      RESULT = parser.nf.Block(parser.pos(n, d),
                parser.nf.SuperCall(parser.pos(n, d),
                Collections.EMPTY_LIST)); 
                      :};

explicit_constructor_invocation ::=
    THIS:a LPAREN argument_list_opt:b RPAREN SEMICOLON:c {:
                                                         RESULT = parser.nf.ThisCall(parser.pos(a, c), b); 
                                                         :}
 |  SUPER:a LPAREN argument_list_opt:b RPAREN SEMICOLON:c {:
                                                          RESULT = parser.nf.SuperCall(parser.pos(a, c), b); 
                                                          :}
 |  primary:a DOT THIS:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c {:
                                                                       RESULT = parser.nf.ThisCall(parser.pos(a, c, n), a, b); 
                                                                       :}
 |  primary:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c {:
                                                                        RESULT = parser.nf.SuperCall(parser.pos(a, c, n), a, b); 
                                                                        :};

interface_declaration ::=
    modifiers_opt:a INTERFACE:n IDENTIFIER:b extends_interfaces_opt:c interface_body:d {:
                                                                                       RESULT = parser.nf.ClassDecl(
                    parser.pos(n, d), a.Interface(),
                        b.getIdentifier(), null, c, d); 
                                                                                       :};

extends_interfaces_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    :}
 |  extends_interfaces:a {:  RESULT = a;  :};

extends_interfaces ::=
    EXTENDS interface_type:a {:
                             List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; 
                             :}
 |  extends_interfaces:a COMMA interface_type:b {:
                                                RESULT = a;
               a.add(b); 
                                                :};

interface_body ::=
    LBRACE:n interface_member_declarations_opt:a RBRACE:d {:
                                                          RESULT = parser.nf.ClassBody(parser.pos(n, d), a); 
                                                          :};

interface_member_declarations_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    :}
 |  interface_member_declarations:a {:  RESULT = a;  :};

interface_member_declarations ::=
    interface_member_declaration:a {:  RESULT = a;  :}
 |  interface_member_declarations:a interface_member_declaration:b {:
                                                                   RESULT = a;
               a.addAll(b); 
                                                                   :};

interface_member_declaration ::=
    constant_declaration:a {:  RESULT = a;  :}
 |  abstract_method_declaration:a {:
                                  List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                                  :}
 |  class_declaration:a {:
                        List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                        :}
 |  interface_declaration:a {:
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                            :}
 |  SEMICOLON {:  RESULT = Collections.EMPTY_LIST;  :}
 |  aspect_declaration:a {:
                         Grm.parserTrace("an interface declaration is an aspect");
       List l = new TypedList(new LinkedList(),
                              ClassMember.class,
                              false);
       l.add(a);
       RESULT = l;
    
                         :}
 |  pointcut_declaration:a {:
                           Grm.parserTrace("an interface member declaration is a pointcut declaration");
       List l = new TypedList(new LinkedList(),
                              ClassMember.class,
                              false);
       l.add(a);
       RESULT = l;
    
                           :};

constant_declaration ::=
    field_declaration:a {:  RESULT = a;  :};

abstract_method_declaration ::=
    method_header:a SEMICOLON {:  RESULT = a;  :};

array_initializer ::=
    LBRACE:n variable_initializers:a COMMA RBRACE:d {:
                                                    RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); 
                                                    :}
 |  LBRACE:n variable_initializers:a RBRACE:d {:
                                              RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); 
                                              :}
 |  LBRACE:n COMMA RBRACE:d {:
                            RESULT = parser.nf.ArrayInit(parser.pos(n, d)); 
                            :}
 |  LBRACE:n RBRACE:d {:
                      RESULT = parser.nf.ArrayInit(parser.pos(n, d)); 
                      :};

variable_initializers ::=
    variable_initializer:a {:
                           List l = new TypedList(new LinkedList(), Expr.class, false);
           l.add(a);
           RESULT = l; 
                           :}
 |  variable_initializers:a COMMA variable_initializer:b {:
                                                         RESULT = a; a.add(b); 
                                                         :};

block ::=
    LBRACE:n block_statements_opt:a RBRACE:d {:
                                             RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                             :};

block_statements_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), Stmt.class, false);  :}
 |  block_statements:a {:  RESULT = a;  :};

block_statements ::=
    block_statement:a {:
                      List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               RESULT = l; 
                      :}
 |  block_statements:a block_statement:b {:
                                         RESULT = a;
               a.addAll(b); 
                                         :};

block_statement ::=
    local_variable_declaration_statement:a {:  RESULT = a;  :}
 |  statement:a {:
                List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               RESULT = l; 
                :}
 |  class_declaration:a {:
                        List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
               RESULT = l; 
                        :}
 |  interface_declaration:a {:
                            List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
               RESULT = l; 
                            :};

local_variable_declaration_statement ::=
    local_variable_declaration:a SEMICOLON {:  RESULT = a;  :};

local_variable_declaration ::=
    type:a variable_declarators:b {:
                                  RESULT = parser.variableDeclarators(a, b, Flags.NONE); 
                                  :}
 |  FINAL type:a variable_declarators:b {:
                                        RESULT = parser.variableDeclarators(a, b, Flags.FINAL); 
                                        :};

statement ::=
    statement_without_trailing_substatement:a {:  RESULT = a;  :}
 |  labeled_statement:a {:  RESULT = a;  :}
 |  if_then_statement:a {:  RESULT = a;  :}
 |  if_then_else_statement:a {:  RESULT = a;  :}
 |  while_statement:a {:  RESULT = a;  :}
 |  for_statement:a {:  RESULT = a;  :};

statement_no_short_if ::=
    statement_without_trailing_substatement:a {:  RESULT = a;  :}
 |  labeled_statement_no_short_if:a {:  RESULT = a;  :}
 |  if_then_else_statement_no_short_if:a {:  RESULT = a;  :}
 |  while_statement_no_short_if:a {:  RESULT = a;  :}
 |  for_statement_no_short_if:a {:  RESULT = a;  :};

statement_without_trailing_substatement ::=
    block:a {:  RESULT = a;  :}
 |  empty_statement:a {:  RESULT = a;  :}
 |  expression_statement:a {:  RESULT = a;  :}
 |  switch_statement:a {:  RESULT = a;  :}
 |  do_statement:a {:  RESULT = a;  :}
 |  break_statement:a {:  RESULT = a;  :}
 |  continue_statement:a {:  RESULT = a;  :}
 |  return_statement:a {:  RESULT = a;  :}
 |  synchronized_statement:a {:  RESULT = a;  :}
 |  throw_statement:a {:  RESULT = a;  :}
 |  try_statement:a {:  RESULT = a;  :}
 |  assert_statement:a {:  RESULT = a;  :};

empty_statement ::=
    SEMICOLON:a {:  RESULT = parser.nf.Empty(parser.pos(a));  :};

labeled_statement ::=
    IDENTIFIER:a COLON statement:b {:
                                   RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b); 
                                   :};

labeled_statement_no_short_if ::=
    IDENTIFIER:a COLON statement_no_short_if:b {:
                                               RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b); 
                                               :};

expression_statement ::=
    statement_expression:a SEMICOLON:d {:
                                       RESULT = parser.nf.Eval(parser.pos(a, d), a); 
                                       :};

statement_expression ::=
    assignment:a {:  RESULT = a;  :}
 |  preincrement_expression:a {:  RESULT = a;  :}
 |  predecrement_expression:a {:  RESULT = a;  :}
 |  postincrement_expression:a {:  RESULT = a;  :}
 |  postdecrement_expression:a {:  RESULT = a;  :}
 |  method_invocation:a {:  RESULT = a;  :}
 |  class_instance_creation_expression:a {:  RESULT = a;  :};

if_then_statement ::=
    IF:n LPAREN expression:a RPAREN statement:b {:
                                                RESULT = parser.nf.If(parser.pos(n, b), a, b); 
                                                :};

if_then_else_statement ::=
    IF:n LPAREN expression:a RPAREN statement_no_short_if:b ELSE statement:c {:
                                                                             RESULT = parser.nf.If(parser.pos(n, c), a, b, c); 
                                                                             :};

if_then_else_statement_no_short_if ::=
    IF:n LPAREN expression:a RPAREN statement_no_short_if:b ELSE statement_no_short_if:c {:
                                                                                         RESULT = parser.nf.If(parser.pos(n, c), a, b, c); 
                                                                                         :};

switch_statement ::=
    SWITCH:n LPAREN expression:a RPAREN switch_block:b {:
                                                       RESULT = parser.nf.Switch(parser.pos(n, b), a, b); 
                                                       :};

switch_block ::=
    LBRACE switch_block_statement_groups:a switch_labels:b RBRACE {:
                                                                  RESULT = a;
               a.addAll(b); 
                                                                  :}
 |  LBRACE switch_block_statement_groups:a RBRACE {:  RESULT = a;  :}
 |  LBRACE switch_labels:a RBRACE {:  RESULT = a;  :}
 |  LBRACE RBRACE {:
                  RESULT = new TypedList(new LinkedList(), SwitchElement.class, false); 
                  :};

switch_block_statement_groups ::=
    switch_block_statement_group:a {:  RESULT = a;  :}
 |  switch_block_statement_groups:a switch_block_statement_group:b {:
                                                                   RESULT = a;
               a.addAll(b); 
                                                                   :};

switch_block_statement_group ::=
    switch_labels:a block_statements:b {:
                                       List l = new TypedList(new LinkedList(), SwitchElement.class, false);
               l.addAll(a); 
               l.add(parser.nf.SwitchBlock(parser.pos(a, b), b));
               RESULT = l; 
                                       :};

switch_labels ::=
    switch_label:a {:
                   List l = new TypedList(new LinkedList(), Case.class, false);
               l.add(a);
               RESULT = l; 
                   :}
 |  switch_labels:a switch_label:b {:
                                   RESULT = a;
               a.add(b); 
                                   :};

switch_label ::=
    CASE:n constant_expression:a COLON:d {:
                                         RESULT = parser.nf.Case(parser.pos(n, d), a); 
                                         :}
 |  DEFAULT:n COLON:d {:
                      RESULT = parser.nf.Default(parser.pos(n, d)); 
                      :};

while_statement ::=
    WHILE:n LPAREN expression:a RPAREN statement:b {:
                                                   RESULT = parser.nf.While(parser.pos(n, b), a, b); 
                                                   :};

while_statement_no_short_if ::=
    WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b {:
                                                               RESULT = parser.nf.While(parser.pos(n, b), a, b); 
                                                               :};

do_statement ::=
    DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON:d {:
                                                                  RESULT = parser.nf.Do(parser.pos(n, d), a, b); 
                                                                  :};

for_statement ::=
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e for_update_opt:c RPAREN statement:d {:
                                                                                                           RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d); 
                                                                                                           :};

for_statement_no_short_if ::=
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e for_update_opt:c RPAREN statement_no_short_if:d {:
                                                                                                                       RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d); 
                                                                                                                       :};

for_init_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), ForInit.class, false); 
    :}
 |  for_init:a {:  RESULT = a;  :};

for_init ::=
    statement_expression_list:a {:  RESULT = a;  :}
 |  local_variable_declaration:a {:
                                 List l = new TypedList(new LinkedList(), ForInit.class, false);
               l.addAll(a);
               RESULT = l; 
                                 :};

for_update_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), ForUpdate.class, false); 
    :}
 |  for_update:a {:  RESULT = a;  :};

for_update ::=
    statement_expression_list:a {:  RESULT = a;  :};

statement_expression_list ::=
    statement_expression:a {:
                           List l = new TypedList(new LinkedList(), Eval.class, false);
               l.add(parser.nf.Eval(parser.pos(a), a));
               RESULT = l; 
                           :}
 |  statement_expression_list:a COMMA statement_expression:b {:
                                                             RESULT = a;
               a.add(parser.nf.Eval(parser.pos(a, b, b), b)); 
                                                             :};

identifier_opt ::=
    {:  RESULT = null;  :}
 |  IDENTIFIER:a {:
                 RESULT = new Name(parser, parser.pos(a), 
                a.getIdentifier()); 
                 :};

break_statement ::=
    BREAK:n identifier_opt:a SEMICOLON:d {:
                                         if (a == null)
                   RESULT = parser.nf.Break(parser.pos(n, d));
               else
                   RESULT = parser.nf.Break(parser.pos(n, d), a.toString()); 
                                         :};

continue_statement ::=
    CONTINUE:n identifier_opt:a SEMICOLON:d {:
                                            if (a == null)
                   RESULT = parser.nf.Continue(parser.pos(n, d));
               else
                   RESULT = parser.nf.Continue(parser.pos(n, d), a.toString()); 
                                            :};

return_statement ::=
    RETURN:n expression_opt:a SEMICOLON:d {:
                                          RESULT = parser.nf.Return(parser.pos(n, d), a); 
                                          :};

throw_statement ::=
    THROW:n expression:a SEMICOLON:d {:
                                     RESULT = parser.nf.Throw(parser.pos(n, d), a); 
                                     :};

synchronized_statement ::=
    SYNCHRONIZED:n LPAREN expression:a RPAREN block:b {:
                                                      RESULT = parser.nf.Synchronized(parser.pos(n, b), a, b); 
                                                      :};

try_statement ::=
    TRY:n block:a catches:b {:
                            RESULT = parser.nf.Try(parser.pos(n, b), a, b); 
                            :}
 |  TRY:n block:a catches_opt:b finally:c {:
                                          RESULT = parser.nf.Try(parser.pos(n, c), a, b, c); 
                                          :};

catches_opt ::=
    {:
    RESULT = new TypedList(new LinkedList(), Catch.class, false); 
    :}
 |  catches:a {:  RESULT = a;  :};

catches ::=
    catch_clause:a {:
                   List l = new TypedList(new LinkedList(), Catch.class, false);
               l.add(a);
               RESULT = l; 
                   :}
 |  catches:a catch_clause:b {:
                             RESULT = a;
               a.add(b); 
                             :};

catch_clause ::=
    CATCH:n LPAREN formal_parameter:a RPAREN block:b {:
                                                     RESULT = parser.nf.Catch(parser.pos(n, b), a, b); 
                                                     :};

finally ::=
    FINALLY block:a {:  RESULT = a;  :};

assert_statement ::=
    ASSERT:x expression:a SEMICOLON:d {:
                                      RESULT = parser.nf.Assert(parser.pos(x, d), a); 
                                      :}
 |  ASSERT:x expression:a COLON expression:b SEMICOLON:d {:
                                                         RESULT = parser.nf.Assert(parser.pos(x, d), a, b); 
                                                         :};

primary ::=
    primary_no_new_array:a {:  RESULT = a;  :}
 |  array_creation_expression:a {:  RESULT = a;  :};

primary_no_new_array ::=
    literal:a {:  RESULT = a;  :}
 |  THIS:a {:  RESULT = parser.nf.This(parser.pos(a));  :}
 |  LPAREN expression:a RPAREN {:  RESULT = a;  :}
 |  class_instance_creation_expression:a {:  RESULT = a;  :}
 |  field_access:a {:  RESULT = a;  :}
 |  method_invocation:a {:  RESULT = a;  :}
 |  array_access:a {:  RESULT = a;  :}
 |  primitive_type:a DOT CLASS:n {:
                                 RESULT = parser.nf.Field(parser.pos(a, n, n), a, "class"); 
                                 :}
 |  VOID:a DOT CLASS:n {:
                       RESULT = parser.nf.Field(parser.pos(a, n, n), 
                parser.nf.CanonicalTypeNode(parser.pos(a),
                parser.ts.Void()), "class"); 
                       :}
 |  array_type:a DOT CLASS:n {:
                             RESULT = parser.nf.Field(parser.pos(a, n, n), a, "class"); 
                             :}
 |  name:a DOT CLASS:n {:
                       RESULT = parser.nf.Field(parser.pos(a, n, n), a.toType(), "class"); 
                       :}
 |  name:a DOT THIS:n {:
                      RESULT = parser.nf.This(parser.pos(a, n, n), a.toType()); 
                      :};

class_instance_creation_expression ::=
    NEW:n class_type:a LPAREN argument_list_opt:b RPAREN:d {:
                                                           RESULT = parser.nf.New(parser.pos(n, d), a, b); 
                                                           :}
 |  NEW:n class_type:a LPAREN argument_list_opt:b RPAREN class_body:c {:
                                                                      RESULT = parser.nf.New(parser.pos(n, c), a, b, c); 
                                                                      :}
 |  primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                        RESULT = parser.nf.New(parser.pos(a, d), a,
				      b.toType(), c); 
                                                                        :}
 |  primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d {:
                                                                                   RESULT = parser.nf.New(parser.pos(a, d), a,
				      b.toType(), c, d); 
                                                                                   :}
 |  name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                     RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(),
				      b.toType(), c); 
                                                                     :}
 |  name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d {:
                                                                                RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(),
				      b.toType(), c, d); 
                                                                                :};

argument_list_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), Expr.class, false);  :}
 |  argument_list:a {:  RESULT = a;  :};

argument_list ::=
    expression:a {:
                 List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; 
                 :}
 |  argument_list:a COMMA expression:b {:
                                       RESULT = a;
               a.add(b); 
                                       :};

array_creation_expression ::=
    NEW:n primitive_type:a dim_exprs:b dims_opt:c {:
                                                  RESULT = parser.nf.NewArray(parser.pos(n, b), a, b,
                c.intValue()); 
                                                  :}
 |  NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c {:
                                                           RESULT = parser.nf.NewArray(parser.pos(n, b), a, b, 
                c.intValue()); 
                                                           :}
 |  NEW:n primitive_type:a dims:b array_initializer:c {:
                                                      RESULT = parser.nf.NewArray(parser.pos(n, c), a,
                b.intValue(), c); 
                                                      :}
 |  NEW:n class_or_interface_type:a dims:b array_initializer:c {:
                                                               RESULT = parser.nf.NewArray(parser.pos(n, c), a,
                b.intValue(), c); 
                                                               :};

dim_exprs ::=
    dim_expr:a {:
               List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; 
               :}
 |  dim_exprs:a dim_expr:b {:  RESULT = a;
               a.add(b);  :};

dim_expr ::=
    LBRACK:x expression:a RBRACK:y {:
                                   RESULT = (Expr)a.position(parser.pos(x,y,a)); 
                                   :};

dims_opt ::=
    {:  RESULT = new Integer(0);  :}
 |  dims:a {:  RESULT = a;  :};

dims ::=
    LBRACK RBRACK {:  RESULT = new Integer(1);  :}
 |  dims:a LBRACK RBRACK {:
                         RESULT = new Integer(a.intValue() + 1); 
                         :};

field_access ::=
    primary:a DOT IDENTIFIER:b {:
                               RESULT = parser.nf.Field(parser.pos(a, b, b), a,
                b.getIdentifier()); 
                               :}
 |  SUPER:n DOT IDENTIFIER:a {:
                             RESULT = parser.nf.Field(parser.pos(a),
                parser.nf.Super(parser.pos(n)),
                a.getIdentifier()); 
                             :}
 |  name:a DOT SUPER:n DOT IDENTIFIER:b {:
                                        RESULT = parser.nf.Field(parser.pos(b),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier()); 
                                        :};

method_invocation ::=
    name:a LPAREN argument_list_opt:b RPAREN:d {:
                                               RESULT = parser.nf.Call(parser.pos(a,d),
                a.prefix == null ? null : a.prefix.toReceiver(),
                a.name, b); 
                                               :}
 |  primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                   RESULT = parser.nf.Call(parser.pos(b,d), a,
                b.getIdentifier(), c); 
                                                                   :}
 |  SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                 RESULT = parser.nf.Call(parser.pos(a,d, b),
                parser.nf.Super(parser.pos(a)),
                b.getIdentifier(), c); 
                                                                 :}
 |  name:a DOT SUPER:n DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                            RESULT = parser.nf.Call(parser.pos(b,d),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier(), c); 
                                                                            :}
 |  PROCEED:a LPAREN argument_list_opt:b RPAREN:d {:
                                                  RESULT = parser.nf.ProceedCall(parser.pos(a,d),parser.nf.This(parser.pos(a)),b);
       
                                                  :};

array_access ::=
    name:a LBRACK expression:b RBRACK:d {:
                                        RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a.toExpr(), b); 
                                        :}
 |  primary_no_new_array:a LBRACK expression:b RBRACK:d {:
                                                        RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, b); 
                                                        :};

postfix_expression ::=
    primary:a {:  RESULT = a;  :}
 |  name:a {:  RESULT = a.toExpr();  :}
 |  postincrement_expression:a {:  RESULT = a;  :}
 |  postdecrement_expression:a {:  RESULT = a;  :};

postincrement_expression ::=
    postfix_expression:a PLUSPLUS:b {:
                                    RESULT = parser.nf.Unary(parser.pos(a,b), a, Unary.POST_INC); 
                                    :};

postdecrement_expression ::=
    postfix_expression:a MINUSMINUS:b {:
                                      RESULT = parser.nf.Unary(parser.pos(a,b), a, Unary.POST_DEC); 
                                      :};

unary_expression ::=
    preincrement_expression:a {:  RESULT = a;  :}
 |  predecrement_expression:a {:  RESULT = a;  :}
 |  PLUS:b unary_expression:a {:
                              RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.POS, a); 
                              :}
 |  MINUS:b unary_expression:a {:
                               RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NEG, a); 
                               :}
 |  unary_expression_not_plus_minus:a {:  RESULT = a;  :};

preincrement_expression ::=
    PLUSPLUS:b unary_expression:a {:
                                  RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.PRE_INC, a); 
                                  :};

predecrement_expression ::=
    MINUSMINUS:b unary_expression:a {:
                                    RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.PRE_DEC, a); 
                                    :};

unary_expression_not_plus_minus ::=
    postfix_expression:a {:  RESULT = a;  :}
 |  COMP:b unary_expression:a {:
                              RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.BIT_NOT, a); 
                              :}
 |  NOT:b unary_expression:a {:
                             RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NOT, a); 
                             :}
 |  cast_expression:a {:  RESULT = a;  :};

cast_expression ::=
    LPAREN:p primitive_type:a dims_opt:b RPAREN unary_expression:c {:
                                                                   RESULT = parser.nf.Cast(parser.pos(p, c,a),
                parser.array(a, b.intValue()), c); 
                                                                   :}
 |  LPAREN:p expression:a RPAREN unary_expression_not_plus_minus:b {:
                                                                   RESULT = parser.nf.Cast(parser.pos(p, b,a),
                parser.exprToType(a), b); 
                                                                   :}
 |  LPAREN:p name:a dims:b RPAREN unary_expression_not_plus_minus:c {:
                                                                    RESULT = parser.nf.Cast(parser.pos(p, c,a),
                parser.array(a.toType(), b.intValue()), c); 
                                                                    :};

multiplicative_expression ::=
    unary_expression:a {:  RESULT = a;  :}
 |  multiplicative_expression:a MULT unary_expression:b {:
                                                        RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.MUL, b); 
                                                        :}
 |  multiplicative_expression:a DIV unary_expression:b {:
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.DIV, b); 
                                                       :}
 |  multiplicative_expression:a MOD unary_expression:b {:
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.MOD, b); 
                                                       :};

additive_expression ::=
    multiplicative_expression:a {:  RESULT = a;  :}
 |  additive_expression:a PLUS multiplicative_expression:b {:
                                                           RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.ADD, b); 
                                                           :}
 |  additive_expression:a MINUS multiplicative_expression:b {:
                                                            RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SUB, b); 
                                                            :};

shift_expression ::=
    additive_expression:a {:  RESULT = a;  :}
 |  shift_expression:a LSHIFT additive_expression:b {:
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SHL, b); 
                                                    :}
 |  shift_expression:a RSHIFT additive_expression:b {:
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SHR, b); 
                                                    :}
 |  shift_expression:a URSHIFT additive_expression:b {:
                                                     RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.USHR, b); 
                                                     :};

relational_expression ::=
    shift_expression:a {:  RESULT = a;  :}
 |  relational_expression:a LT shift_expression:b {:
                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.LT, b); 
                                                  :}
 |  relational_expression:a GT shift_expression:b {:
                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.GT, b); 
                                                  :}
 |  relational_expression:a LTEQ shift_expression:b {:
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.LE, b); 
                                                    :}
 |  relational_expression:a GTEQ shift_expression:b {:
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.GE, b); 
                                                    :}
 |  relational_expression:a INSTANCEOF reference_type:b {:
                                                        RESULT = parser.nf.Instanceof(parser.pos(a, b), a, b); 
                                                        :};

equality_expression ::=
    relational_expression:a {:  RESULT = a;  :}
 |  equality_expression:a EQEQ relational_expression:b {:
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.EQ, b); 
                                                       :}
 |  equality_expression:a NOTEQ relational_expression:b {:
                                                        RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.NE, b); 
                                                        :};

and_expression ::=
    equality_expression:a {:  RESULT = a;  :}
 |  and_expression:a AND equality_expression:b {:
                                               RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_AND, b); 
                                               :};

exclusive_or_expression ::=
    and_expression:a {:  RESULT = a;  :}
 |  exclusive_or_expression:a XOR and_expression:b {:
                                                   RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_XOR, b); 
                                                   :};

inclusive_or_expression ::=
    exclusive_or_expression:a {:  RESULT = a;  :}
 |  inclusive_or_expression:a OR exclusive_or_expression:b {:
                                                           RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_OR, b); 
                                                           :};

conditional_and_expression ::=
    inclusive_or_expression:a {:  RESULT = a;  :}
 |  conditional_and_expression:a ANDAND inclusive_or_expression:b {:
                                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.COND_AND, b); 
                                                                  :};

conditional_or_expression ::=
    conditional_and_expression:a {:  RESULT = a;  :}
 |  conditional_or_expression:a OROR conditional_and_expression:b {:
                                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.COND_OR, b); 
                                                                  :};

conditional_expression ::=
    conditional_or_expression:a {:  RESULT = a;  :}
 |  conditional_or_expression:a QUESTION expression:b COLON conditional_expression:c {:
                                                                                     RESULT = parser.nf.Conditional(parser.pos(a, c), a, 
                b, c); 
                                                                                     :};

assignment_expression ::=
    conditional_expression:a {:  RESULT = a;  :}
 |  assignment:a {:  RESULT = a;  :};

assignment ::=
    left_hand_side:a assignment_operator:b assignment_expression:c {:
                                                                   RESULT = parser.nf.Assign(parser.pos(a, c), a, b, c); 
                                                                   :};

left_hand_side ::=
    name:a {:  RESULT = a.toExpr();  :}
 |  field_access:a {:  RESULT = a;  :}
 |  array_access:a {:  RESULT = a;  :};

assignment_operator ::=
    EQ {:  RESULT = Assign.ASSIGN;  :}
 |  MULTEQ {:  RESULT = Assign.MUL_ASSIGN;  :}
 |  DIVEQ {:  RESULT = Assign.DIV_ASSIGN;  :}
 |  MODEQ {:  RESULT = Assign.MOD_ASSIGN;  :}
 |  PLUSEQ {:  RESULT = Assign.ADD_ASSIGN;  :}
 |  MINUSEQ {:  RESULT = Assign.SUB_ASSIGN;  :}
 |  LSHIFTEQ {:  RESULT = Assign.SHL_ASSIGN;  :}
 |  RSHIFTEQ {:  RESULT = Assign.SHR_ASSIGN;  :}
 |  URSHIFTEQ {:  RESULT = Assign.USHR_ASSIGN;  :}
 |  ANDEQ {:  RESULT = Assign.BIT_AND_ASSIGN;  :}
 |  XOREQ {:  RESULT = Assign.BIT_XOR_ASSIGN;  :}
 |  OREQ {:  RESULT = Assign.BIT_OR_ASSIGN;  :};

expression_opt ::=
    {:  RESULT = null;  :}
 |  expression:a {:  RESULT = a;  :};

expression ::=
    assignment_expression:a {:  RESULT = a;  :};

constant_expression ::=
    expression:a {:  RESULT = a;  :};

aspect_declaration ::=
    modifiers_opt:a PRIVILEGED modifiers_opt:a1 ASPECT:n IDENTIFIER:b super_opt:c interfaces_opt:d perclause_opt:f aspect_body:g {:
                                                                                                                                 Grm.parserTrace( "PRIVILEGED aspect declaration: " + 
                                               b.getIdentifier()); 
          RESULT = parser.nf.AspectDecl(parser.pos(n,g),
                                        true,
                                        a.set(a1),
                                        b.getIdentifier(),
                                        c,
                                        d,
                                        f,
                                        g); // ignore per-clause for now
       
                                                                                                                                 :}
 |  modifiers_opt:a ASPECT:n IDENTIFIER:b super_opt:c interfaces_opt:d perclause_opt:f aspect_body:g {:
                                                                                                     Grm.parserTrace( "aspect declaration: " + 
                                               b.getIdentifier()); 
          RESULT = parser.nf.AspectDecl(parser.pos(n,g),
                                        false,
                                        a,
                                        b.getIdentifier(),
                                        c,
                                        d,
                                        f,
                                        g); // ignore per-clause for now
       
                                                                                                     :};

perclause_opt ::=
    perclause:a {:
                Grm.parserTrace("non-empty perclause in perclause_opt");
          RESULT = a;
       
                :}
 |  {:
    Grm.parserTrace("empty perclause in perclause_opt");
          RESULT = null;
       
    :};

perclause ::=
    PERTARGET:per LPAREN pointcut_expr:pc RPAREN:d {:
                                                   Grm.parserTrace("pertarget");
          RESULT = parser.nf.PerTarget(parser.pos(per,d),pc);
       
                                                   :}
 |  PERTHIS:per LPAREN pointcut_expr:pc RPAREN:d {:
                                                 Grm.parserTrace("perthis");
          RESULT = parser.nf.PerThis(parser.pos(per,d),pc);
       
                                                 :}
 |  PERCFLOW:per LPAREN pointcut_expr:pc RPAREN:d {:
                                                  Grm.parserTrace("percflow");
          RESULT = parser.nf.PerCflow(parser.pos(per,d),pc);
       
                                                  :}
 |  PERCFLOWBELOW:per LPAREN pointcut_expr:pc RPAREN:d {:
                                                       Grm.parserTrace("percflowbelow");
          RESULT = parser.nf.PerCflowBelow(parser.pos(per,d),pc);
       
                                                       :}
 |  ISSINGLETON:per {:
                    Grm.parserTrace("isingleton");
          RESULT = parser.nf.IsSingleton(parser.pos(per));
       
                    :}
 |  ISSINGLETON:per LPAREN RPAREN:d {:
                                    Grm.parserTrace("isingleton");
          RESULT = parser.nf.IsSingleton(parser.pos(per,d));
       
                                    :};

aspect_body ::=
    LBRACE:lb RBRACE:rb {:
                        Grm.parserTrace("empty aspect body"); 
           RESULT = parser.nf.AspectBody(parser.pos(lb,rb),
                                         new TypedList(new LinkedList(), 
                                                       ClassMember.class, 
                                                       false)); 
        
                        :}
 |  LBRACE:lb aspect_body_declarations:a RBRACE:rb {:
                                                   Grm.parserTrace("aspect body"); 
          RESULT = parser.nf.AspectBody(parser.pos(lb,rb),a); 
       
                                                   :};

aspect_body_declarations ::=
    aspect_body_declaration:a {:
                              Grm.parserTrace("aspect_body_declaration");
          RESULT = new TypedList(new LinkedList(), ClassMember.class, false);
          RESULT.addAll(a);
       
                              :}
 |  aspect_body_declarations:a aspect_body_declaration:b {:
                                                         Grm.parserTrace("aspect_body_declarations");
          RESULT = a;
          a.addAll(b);
       
                                                         :};

aspect_body_declaration ::=
    class_body_declaration:a {:
                             Grm.parserTrace("aspect_body_declaration is just a class_body_declaration\n");
          Grm.parserTrace("LINE " + parser.pos(a));
          Grm.parserTrace("-----------------------------------------------\n");
          RESULT = a;
       
                             :}
 |  declare_declaration:a {:
                          Grm.parserTrace("declare declaration\n");
          Grm.parserTrace("LINE " + parser.pos(a));
          Grm.parserTrace("-----------------------------------------------\n");
          List ds = new TypedList(new LinkedList(),ClassMember.class,false);
          ds.add(a);
          RESULT = ds;
       
                          :}
 |  advice_declaration:a {:
                         Grm.parserTrace("advice declaration\n");
          Grm.parserTrace("LINE " + parser.pos(a));
          Grm.parserTrace("-----------------------------------------------\n");
          List ds = new TypedList(new LinkedList(),ClassMember.class,false);
          ds.add(a);
          RESULT = ds;
       
                         :}
 |  intertype_member_declaration:a {:
                                   Grm.parserTrace("intertype_member_declaration\n");
          Grm.parserTrace("LINE " + parser.pos(a));
          Grm.parserTrace("-----------------------------------------------\n");
          List ds = new TypedList(new LinkedList(),ClassMember.class,false);
          ds.add(a);
          RESULT = ds;
       
                                   :};

declare_declaration ::=
    DECLARE:d PC_PARENTS COLON classname_pattern_expr:a EXTENDS class_type:b SEMICOLON:e {:
                                                                                         Grm.parserTrace("Declare class extension");
          DeclareParentsExt dpe = parser.nf.DeclareParentsExt(parser.pos(d,e),a,b);
          RESULT = dpe;
       
                                                                                         :}
 |  DECLARE:d PC_PARENTS COLON classname_pattern_expr:a IMPLEMENTS interface_type_list:b SEMICOLON:e {:
                                                                                                     Grm.parserTrace("Declare interface extension");
          DeclareParentsImpl dpi = parser.nf.DeclareParentsImpl(parser.pos(d,e),a,b);
          RESULT = dpi;
       
                                                                                                     :}
 |  DECLARE:d PC_WARNING COLON pointcut_expr:a COLON STRING_LITERAL:b SEMICOLON:e {:
                                                                                  Grm.parserTrace("Declare warning:" + b.getValue());
          DeclareWarning dw = parser.nf.DeclareWarning(parser.pos(d,e),a,b.getValue());
          RESULT = dw;
       
                                                                                  :}
 |  DECLARE:d PC_ERROR COLON pointcut_expr:a COLON STRING_LITERAL:b SEMICOLON:e {:
                                                                                Grm.parserTrace("Declare error:" + b.getValue());
          DeclareError de = parser.nf.DeclareError(parser.pos(d,e),a,b.getValue());
          RESULT = de;
       
                                                                                :}
 |  DECLARE:d PC_SOFT COLON type:a COLON pointcut_expr:b SEMICOLON:e {:
                                                                     Grm.parserTrace("Declare soft");
          DeclareSoft ds = parser.nf.DeclareSoft(parser.pos(d,e),a,b);
          RESULT = ds;
       
                                                                     :}
 |  DECLARE:d PC_PRECEDENCE COLON classname_pattern_expr_list:a SEMICOLON:e {:
                                                                            Grm.parserTrace("Declare precedence");
          DeclarePrecedence dp = parser.nf.DeclarePrecedence(parser.pos(a),a);
          RESULT = dp;
       
                                                                            :};

pointcut_declaration ::=
    modifiers_opt:a POINTCUT IDENTIFIER:b LPAREN formal_parameter_list_opt:c RPAREN SEMICOLON:e {:
                                                                                                Grm.parserTrace("abstract pointcut declaration");
         TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(b),
                                                        parser.ts.Void());
        PointcutDecl pcd = parser.nf.PointcutDecl(parser.pos(b,e),
                                                  a,
                                                  b.getIdentifier(),
                                                  c,
                                                  null,
                                                  voidn);
        RESULT = pcd;
     
                                                                                                :}
 |  modifiers_opt:a POINTCUT IDENTIFIER:b LPAREN formal_parameter_list_opt:c RPAREN COLON pointcut_expr:d SEMICOLON:e {:
                                                                                                                      Grm.parserTrace("non-abstract pointcut declaration");
        TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(b),
                                                        parser.ts.Void());
        PointcutDecl pcd = parser.nf.PointcutDecl(parser.pos(b,e),
                                                  a,
                                                  b.getIdentifier(),
                                                  c,
                                                  d, voidn);
        RESULT = pcd;
     
                                                                                                                      :};

advice_declaration ::=
    modifiers_opt:m advice_spec:a throws_opt:b COLON pointcut_expr:c method_body:d {:
                                                                                   Grm.parserTrace("advice declaration without strictfp");
          AdviceDecl ad = parser.nf.AdviceDecl(parser.pos(a,d),
					       m,
                                               a,
                                               b,
					       c,
	                                       d);
          RESULT = ad;
       
                                                                                   :};

advice_spec ::=
    BEFORE:x LPAREN formal_parameter_list_opt:a RPAREN:y {:
                                                         Grm.parserTrace("before(formals)");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
          Before b = parser.nf.Before(parser.pos(x,y),a,voidn);
          RESULT = b;
       
                                                         :}
 |  AFTER:x LPAREN formal_parameter_list_opt:a RPAREN:y {:
                                                        Grm.parserTrace("after(formals)");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
	      After after = parser.nf.After(parser.pos(x,y),a,voidn);
          RESULT = after;
       
                                                        :}
 |  AFTER:x LPAREN formal_parameter_list_opt:a RPAREN PC_RETURNING:y {:
                                                                     Grm.parserTrace("after(formals)returning");
        TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
	  AfterReturning afterRet = parser.nf.AfterReturning(parser.pos(x,y),
	                                                     a,
                                                         null,
                                                         voidn);
          RESULT = afterRet;
       
                                                                     :}
 |  AFTER:x LPAREN formal_parameter_list_opt:a RPAREN PC_RETURNING LPAREN RPAREN:y {:
                                                                                   Grm.parserTrace("after(formals)returning()");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
	      AfterReturning afterRet = parser.nf.AfterReturning(parser.pos(x,y),
	                                                         a,
                                                             null,
                                                             voidn);
          RESULT = afterRet;
       
                                                                                   :}
 |  AFTER:x LPAREN formal_parameter_list_opt:a RPAREN PC_RETURNING LPAREN formal_parameter:b RPAREN:y {:
                                                                                                      Grm.parserTrace("after(formals) returning(p)");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
	      AfterReturning afterRet = parser.nf.AfterReturning(parser.pos(x,y),
                                                             a,
                                                             b,
                                                             voidn);
          RESULT = afterRet;
       
                                                                                                      :}
 |  AFTER:x LPAREN formal_parameter_list_opt:a RPAREN PC_THROWING:y {:
                                                                    Grm.parserTrace("after(formals)throwing");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
          AfterThrowing afterThrow = parser.nf.AfterThrowing(parser.pos(x,y),
                                                             a,
							                                 null,
							                                 voidn);
          RESULT = afterThrow;
       
                                                                    :}
 |  AFTER:x LPAREN formal_parameter_list_opt:a RPAREN PC_THROWING LPAREN formal_parameter:b RPAREN:y {:
                                                                                                     Grm.parserTrace("after(formals)throwing(p)");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
          AfterThrowing afterThrow = parser.nf.AfterThrowing(parser.pos(x,y),
                                                             a,
							                                 b,
							                                 voidn);
          RESULT = afterThrow;
       
                                                                                                     :}
 |  type:a AROUND LPAREN formal_parameter_list_opt:b RPAREN:y {:
                                                              Grm.parserTrace("non-void-type around (formals)");
          Around around = parser.nf.Around(parser.pos(a,y),
                                           a,
                                           b);
          RESULT = around;
       
                                                              :}
 |  VOID:a AROUND LPAREN formal_parameter_list_opt:b RPAREN:y {:
                                                              Grm.parserTrace("VOID around (formals)");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(a),
                                                        parser.ts.Void());
          Around around = parser.nf.Around(parser.pos(a,y),
                                           voidn,
                                           b);
          RESULT = around;
       
                                                              :};

intertype_member_declaration ::=
    modifiers_opt:a VOID:b name:c DOT IDENTIFIER:d LPAREN formal_parameter_list_opt:e RPAREN throws_opt:f method_body:g {:
                                                                                                                        Grm.parserTrace("Intertype VOID METHOD declaration");
          TypeNode voidn =  parser.nf.CanonicalTypeNode(parser.pos(b),
                                                        parser.ts.Void());
          IntertypeMethodDecl imd 
            = parser.nf.IntertypeMethodDecl(parser.pos(b,g),
                                      a,
                                      voidn,
				      c.toType(),
				      d.getIdentifier(),
                                      e,
                                      f,
                                      g);                                     
           RESULT = imd;
       
                                                                                                                        :}
 |  modifiers_opt:a type:b name:c DOT IDENTIFIER:d LPAREN formal_parameter_list_opt:e RPAREN throws_opt:f method_body:g {:
                                                                                                                        Grm.parserTrace("Intertype METHOD declaration");
           IntertypeMethodDecl imd 
            = parser.nf.IntertypeMethodDecl(parser.pos(b,g),
                                      a,
                                      b,
				      c.toType(),
				      d.getIdentifier(),
                                      e,
                                      f,
                                      g);                                     
           RESULT = imd;
       
                                                                                                                        :}
 |  modifiers_opt:a name:b DOT NEW LPAREN formal_parameter_list_opt:c RPAREN throws_opt:d constructor_body:e {:
                                                                                                             Grm.parserTrace("Intertype CONSTRUCTOR declaration");
          IntertypeConstructorDecl icd
           = parser.nf.IntertypeConstructorDecl(parser.pos(b,e),
                                        a,
					b.toType(),
					b.toString(),
					c,
					d,
					e);		
          RESULT = icd;
       
                                                                                                             :}
 |  modifiers_opt:a type:b name:c DOT IDENTIFIER:d SEMICOLON {:
                                                             Grm.parserTrace("Intertype FIELD without initializer");
          IntertypeFieldDecl ifd
	   = parser.nf.IntertypeFieldDecl(parser.pos(b),
                                          a,
                                          b,
                                          c.toType(),
                                          d.getIdentifier(),
                                          null);
          RESULT = ifd;
       
                                                             :}
 |  modifiers_opt:a type:b name:c DOT IDENTIFIER:d EQ variable_initializer:e SEMICOLON {:
                                                                                       Grm.parserTrace("Intertype FIELD with initializer");
          IntertypeFieldDecl ifd
	   = parser.nf.IntertypeFieldDecl(parser.pos(b,d),
                                          a,
                                          b,
                                          c.toType(),
                                          d.getIdentifier(),
                                          e);
          RESULT = ifd;
       
                                                                                       :};

pointcut_expr ::=
    and_pointcut_expr:a {:
                       Grm.parserTrace("pointcut_expr is an and_pointcut_expr");
           RESULT = a;
        
                       :}
 |  pointcut_expr:a PC_OROR and_pointcut_expr:b {:
                                                 Grm.parserTrace("pointcut_expr || and_pointcut_expr");
           RESULT = parser.nf.PCBinary(parser.pos(a,b),a,PCBinary.COND_OR,b);
        
                                                 :};

and_pointcut_expr ::=
    unary_pointcut_expr:a {:
                          Grm.parserTrace("and_pointcut_expr is a unary_pointcut_expr");
           RESULT = a;
        
                          :}
 |  and_pointcut_expr:a PC_ANDAND unary_pointcut_expr:b {:
                                                     Grm.parserTrace("and_pointcut_expr && unary_pointcut_expr");
           RESULT = parser.nf.PCBinary(parser.pos(a,b),a,PCBinary.COND_AND,b);
        
                                                     :};

unary_pointcut_expr ::=
    basic_pointcut_expr:a {:
                          Grm.parserTrace("unary_pointcut_expr is a basic_pointcut_expr");
           RESULT = a;
        
                          :}
 |  PC_NOT unary_pointcut_expr:a {:
                                 Grm.parserTrace("! unary_pointcut_expr");
           PCNot pcn = parser.nf.PCNot(parser.pos(a),a);
           RESULT = pcn;
        
                                 :};

basic_pointcut_expr ::=
    LPAREN pointcut_expr:a RPAREN {:
                                  Grm.parserTrace("basic_pointcut_expr is ( pointcut_expr )");
          RESULT = a;
       
                                  :}
 |  PC_CALL:x LPAREN method_constructor_pattern:a RPAREN:y {:
                                                           Grm.parserTrace("CALL pointcut");
          RESULT = parser.nf.PCCall(parser.pos(x,y),a);
       
                                                           :}
 |  PC_EXECUTION:x LPAREN method_constructor_pattern:a RPAREN:y {:
                                                                Grm.parserTrace("EXECUTION pointcut");
          RESULT = parser.nf.PCExecution(parser.pos(x,y),a);
       
                                                                :}
 |  PC_INITIALIZATION:x LPAREN constructor_pattern:a RPAREN:y {:
                                                              Grm.parserTrace("INITIALIZATION pointcut");
          RESULT = parser.nf.PCInitialization(parser.pos(x,y),a);
       
                                                              :}
 |  PC_PREINITIALIZATION:x LPAREN constructor_pattern:a RPAREN:y {:
                                                                 Grm.parserTrace("PREINITIALIZATION pointcut");
          RESULT = parser.nf.PCPreinitialization(parser.pos(x,y),a);
       
                                                                 :}
 |  PC_STATICINITIALIZATION:x LPAREN classname_pattern_expr:a RPAREN:y {:
                                                                       Grm.parserTrace("STATICINITIALIZATION pointcut");
          RESULT = parser.nf.PCStaticInitialization(parser.pos(x,y),a);
       
                                                                       :}
 |  PC_GET:x LPAREN field_pattern:a RPAREN:y {:
                                             Grm.parserTrace("GET pointcut");
          RESULT = parser.nf.PCGet(parser.pos(x,y),a);
       
                                             :}
 |  PC_SET:x LPAREN field_pattern:a RPAREN:y {:
                                             Grm.parserTrace("SET pointcut");
          RESULT = parser.nf.PCSet(parser.pos(x,y),a);
       
                                             :}
 |  PC_HANDLER:x LPAREN classname_pattern_expr:a RPAREN:y {:
                                                          Grm.parserTrace("HANDLER pointcut");
          RESULT = parser.nf.PCHandler(parser.pos(x,y),a);
       
                                                          :}
 |  PC_ADVICEEXECUTION:a LPAREN RPAREN:y {:
                                         Grm.parserTrace("ADVICEEXECUTION pointcut");
          RESULT = parser.nf.PCAdviceExecution(parser.pos(a,y));
       
                                         :}
 |  PC_WITHIN:x LPAREN classname_pattern_expr:a RPAREN:y {:
                                                         Grm.parserTrace("WITHIN pointcut on pattern");
          RESULT = parser.nf.PCWithin(parser.pos(x,y),a);
       
                                                         :}
 |  PC_WITHINCODE:x LPAREN method_constructor_pattern:a RPAREN:y {:
                                                                 Grm.parserTrace("WITHINCODE pointcut on method_constructor_pattern");
          RESULT = parser.nf.PCWithinCode(parser.pos(x,y),a);
       
                                                                 :}
 |  PC_CFLOW:x LPAREN pointcut_expr:a RPAREN:y {:
                                               Grm.parserTrace("CFLOW pointcut");
          RESULT = parser.nf.PCCflow(parser.pos(x,y),a);
       
                                               :}
 |  PC_CFLOWBELOW:x LPAREN pointcut_expr:a RPAREN:y {:
                                                    Grm.parserTrace("CFLOWBELOW pointcut");
          RESULT = parser.nf.PCCflowBelow(parser.pos(x,y),a);
       
                                                    :}
 |  PC_IF:x LPAREN expression:a RPAREN:y {:
                                         Grm.parserTrace("IF pointcut");
          RESULT = parser.nf.PCIf(parser.pos(x,y),a);
       
                                         :}
 |  PC_THIS:x LPAREN type_id_star:a RPAREN:y {:
                                             Grm.parserTrace("THIS pointcut");
          RESULT = parser.nf.PCThis(parser.pos(x,y),a);
       
                                             :}
 |  PC_TARGET:x LPAREN type_id_star:a RPAREN:y {:
                                               Grm.parserTrace("TARGET pointcut");
          RESULT = parser.nf.PCTarget(parser.pos(x,y),a);
       
                                               :}
 |  PC_ARGS:x LPAREN type_id_star_list_opt:a RPAREN:y {:
                                                      Grm.parserTrace("ARGS pointcut");
          RESULT = parser.nf.PCArgs(parser.pos(x,y),a);
       
                                                      :}
 |  name:a LPAREN type_id_star_list_opt:b RPAREN:y {:
                                                   RESULT = parser.nf.PCName(parser.pos(a,y),
                a.prefix == null ? null : a.prefix.toReceiver(),
                a.name, b); 
                                                   :};

name_pattern ::=
    simple_name_pattern:a {:  RESULT = a;
         :}
 |  name_pattern:a DOT simple_name_pattern:b {:
                                             RESULT = parser.nf.DotNamePattern(parser.pos(a,b),a,b);
        
                                             :}
 |  name_pattern:a PC_DOTDOT:d simple_name_pattern:b {:
                                                     DotDotNamePattern ddnp = parser.nf.DotDotNamePattern(parser.pos(a,d),a);
           RESULT = parser.nf.DotNamePattern(parser.pos(a,b),ddnp,b);
        
                                                     :};

simple_name_pattern ::=
    PC_MULT:m {:
              Grm.parserTrace("name_pattern is a star: ");
           RESULT = parser.nf.SimpleNamePattern(parser.pos(m),"*");
        
              :}
 |  IDENTIFIERPATTERN:a {:
                        Grm.parserTrace("name_pattern is simple name pattern: " + a);
           RESULT = parser.nf.SimpleNamePattern(parser.pos(a),a.getIdentifier());
        
                        :}
 |  IDENTIFIER:a {:
                 Grm.parserTrace("name_pattern is identifer: " + a);
           RESULT = parser.nf.SimpleNamePattern(parser.pos(a),a.getIdentifier());
        
                 :}
 |  aspectj_reserved_identifier:a {:
                                  Grm.parserTrace("name_pattern is aspectj_reserved_identifier");
	   String token = a.toString();
           String keyword = token.substring(8,token.length()-1);
           RESULT = parser.nf.SimpleNamePattern(parser.pos(a),keyword);
        
                                  :};

aspectj_reserved_identifier ::=
    ASPECT:a {:
             Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
             :}
 |  PRIVILEGED:a {:
                 Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                 :}
 |  PC_ADVICEEXECUTION:a {:
                         Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                         :}
 |  PC_ARGS:a {:
              Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
              :}
 |  PC_CALL:a {:
              Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
              :}
 |  PC_CFLOW:a {:
               Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
               :}
 |  PC_CFLOWBELOW:a {:
                    Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                    :}
 |  PC_ERROR:a {:
               Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
               :}
 |  PC_EXECUTION:a {:
                   Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                   :}
 |  PC_GET:a {:
             Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
             :}
 |  PC_HANDLER:a {:
                 Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                 :}
 |  PC_INITIALIZATION:a {:
                        Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                        :}
 |  PC_PARENTS:a {:
                 Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                 :}
 |  PC_PRECEDENCE:a {:
                    Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                    :}
 |  PC_PREINITIALIZATION:a {:
                           Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                           :}
 |  PC_RETURNING:a {:
                   Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                   :}
 |  PC_SET:a {:
             Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
             :}
 |  PC_SOFT:a {:
              Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
              :}
 |  PC_STATICINITIALIZATION:a {:
                              Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                              :}
 |  PC_TARGET:a {:
                Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                :}
 |  PC_THROWING:a {:
                  Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                  :}
 |  PC_WARNING:a {:
                 Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                 :}
 |  PC_WITHINCODE:a {:
                    Grm.parserTrace("aspectj_reserved_identifier: " + a);
           RESULT = a;
        
                    :};

classtype_dot_id ::=
    simple_name_pattern:b {:
                          Grm.parserTrace("classtype_dot_id is simple_name_pattern: ");
           ClassnamePatternExpr cpe = parser.nf.CPEUniversal(parser.pos(b));
	   RESULT = parser.nf.ClassTypeDotId(parser.pos(b),cpe,b);
        
                          :}
 |  name_pattern:a DOT simple_name_pattern:b {:
                                             Grm.parserTrace("classtype_dot_id is np . simple_name_pattern");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a));
	   } else {
	       cpe = parser.nf.CPEName(parser.pos(a), a);
	   }
           RESULT = parser.nf.ClassTypeDotId(parser.pos(a,b),cpe,b);
        
                                             :}
 |  name_pattern:a PLUS:p DOT simple_name_pattern:b {:
                                                    Grm.parserTrace("classtype_dot_id is np + . simple_name_pattern");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a));
	   } else {
	       cpe = parser.nf.CPESubName(parser.pos(a,p), a);
	   }
           RESULT = parser.nf.ClassTypeDotId(parser.pos(a,b),cpe,b);
        
                                                    :}
 |  name_pattern:a PC_DOTDOT:d simple_name_pattern:b {:
                                                     Grm.parserTrace("classtype_dot_id is np . simple_name_pattern");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a));
	   } else {
	       DotDotNamePattern np = parser.nf.DotDotNamePattern(parser.pos(a,d),a);
	       cpe = parser.nf.CPEName(parser.pos(np), np);
	   }
           RESULT = parser.nf.ClassTypeDotId(parser.pos(a,b),cpe,b);
        
                                                     :}
 |  LPAREN:x type_pattern_expr:a RPAREN:y DOT simple_name_pattern:b {:
                                                                    Grm.parserTrace("(tpe) . new");
          ClassnamePatternExpr cpe = parser.nf.constructClassnamePatternFromTypePattern(a);
          RESULT = parser.nf.ClassTypeDotId(parser.pos(x,y),cpe,b);
       
                                                                    :};

classtype_dot_new ::=
    NEW:a {:
          Grm.parserTrace("classtype_dot_new is NEW: ");
           ClassnamePatternExpr cpe = parser.nf.CPEUniversal(parser.pos(a));
	   RESULT = parser.nf.ClassTypeDotNew(parser.pos(a),cpe);
        
          :}
 |  name_pattern:a DOT NEW:y {:
                             Grm.parserTrace("classtype_dot_new is np . NEW");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a));
	   } else {
	       cpe = parser.nf.CPEName(parser.pos(a), a);
	   }
           RESULT = parser.nf.ClassTypeDotNew(parser.pos(a,y),cpe);
        
                             :}
 |  name_pattern:a PLUS:p DOT NEW:y {:
                                    Grm.parserTrace("classtype_dot_new is np + . NEW");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a,p));
	   } else {
	       cpe = parser.nf.CPESubName(parser.pos(a,p), a);
	   }
           RESULT = parser.nf.ClassTypeDotNew(parser.pos(a,y),cpe);
        
                                    :}
 |  name_pattern:a PC_DOTDOT:d NEW:y {:
                                     Grm.parserTrace("classtype_dot_new is np . NEW");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a));
	   } else {
	       DotDotNamePattern np = parser.nf.DotDotNamePattern(parser.pos(a,d),a);
	       cpe = parser.nf.CPEName(parser.pos(np), np);
	   }
           RESULT = parser.nf.ClassTypeDotNew(parser.pos(a,y),cpe);
        
                                     :}
 |  LPAREN:x type_pattern_expr:a RPAREN DOT NEW:y {:
                                                  Grm.parserTrace("(tpe) . new");
          ClassnamePatternExpr cpe = parser.nf.constructClassnamePatternFromTypePattern(a);
          RESULT = parser.nf.ClassTypeDotNew(parser.pos(x,y),cpe);
       
                                                  :};

type_pattern_expr ::=
    or_type_pattern_expr:a {:
                           Grm.parserTrace("type_pattern_expr is an or_type_pattern_expr");
           RESULT = a;
        
                           :}
 |  type_pattern_expr:a PC_ANDAND or_type_pattern_expr:b {:
                                                         Grm.parserTrace("type_pattern_expr && or_type_pattern_expr");
           RESULT = parser.nf.TPEBinary(parser.pos(a,b),
					a,
					TPEBinary.COND_AND,
                                        b);
        
                                                         :};

or_type_pattern_expr ::=
    unary_type_pattern_expr:a {:
                              Grm.parserTrace("or_type_pattern_expr is a unary_type_pattern_expr");
           RESULT = a;
        
                              :}
 |  or_type_pattern_expr:a PC_OROR unary_type_pattern_expr:b {:
                                                             Grm.parserTrace("or_type_pattern_expr || unary_type_pattern_expr");
           RESULT = parser.nf.TPEBinary(parser.pos(a,b),
                                        a,
                                        TPEBinary.COND_OR,
                                        b);
        
                                                             :};

unary_type_pattern_expr ::=
    basic_type_pattern:a {:
                         Grm.parserTrace("unary_type_pattern_expr is a  basic_type_pattern");
           RESULT = a;
        
                         :}
 |  PC_NOT:a unary_type_pattern_expr:b {:
                                       Grm.parserTrace("! unary_type_pattern_expr");
           RESULT = parser.nf.TPENot(parser.pos(a,b),b);
        
                                       :};

basic_type_pattern ::=
    VOID:a {:
           Grm.parserTrace("VOID type");
          TypeNode vn = parser.nf.CanonicalTypeNode(parser.pos(a),
                                                    parser.ts.Void());
          RESULT = parser.nf.TPEType(parser.pos(a),vn);
       
           :}
 |  base_type_pattern:a {:
                        Grm.parserTrace("basic_type_pattern is a reference_type_pattern");
          RESULT = a;
       
                        :}
 |  base_type_pattern:a dims:b {:
                               Grm.parserTrace("basic_type_pattern is just a primitive_type");
          RESULT = parser.nf.TPEArray(parser.pos(a),a,b.intValue());
       
                               :}
 |  LPAREN:lp type_pattern_expr:a RPAREN:rp {:
                                            Grm.parserTrace("basic_type_pattern is a ( type_pattern_expr )");
          RESULT = a;
       
                                            :};

base_type_pattern ::=
    primitive_type:a {:
                     Grm.parserTrace("basic_type_pattern is just a primitive_type");
          RESULT = parser.nf.TPEType(parser.pos(a),a);
       
                     :}
 |  name_pattern:a {:
                   Grm.parserTrace("reference_type_pattern is a name_pattern");
          TypePatternExpr tpe;
          if (a.universal()) {
	      tpe = parser.nf.TPEUniversal(parser.pos(a));
          } else {
	      tpe = parser.nf.TPERefTypePat(parser.pos(a),
					    parser.nf.RTPName(parser.pos(a),a));
	  }
	  RESULT = tpe;
       
                   :}
 |  name_pattern:a PC_PLUS:p {:
                             Grm.parserTrace("reference_type_pattern is name_pattern +");
          TypePatternExpr tpe;
          if (a.universal()) {
	      tpe = parser.nf.TPEUniversal(parser.pos(a,p));
          } else {
	      tpe = parser.nf.TPERefTypePat(parser.pos(a),
					    parser.nf.RTPSubName(parser.pos(a,p),a));
	  }
          RESULT = tpe;
       
                             :};

classname_pattern_expr_list ::=
    classname_pattern_expr:a {:
                             Grm.parserTrace("first item of classname_pattern_expr_list");
          RESULT = new TypedList(new LinkedList(),
				 ClassnamePatternExpr.class,
                                 false);
          RESULT.add(a);
       
                             :}
 |  classname_pattern_expr_list:a COMMA classname_pattern_expr:b {:
                                                                 Grm.parserTrace("another item of classname_pattern_expr_list");
          a.add(b);
          RESULT = a;
       
                                                                 :};

classname_pattern_expr ::=
    or_classname_pattern_expr:a {:
                                Grm.parserTrace("classname_pattern_expr is an or_classname_pattern_expr");
           RESULT = a;
        
                                :}
 |  classname_pattern_expr:a PC_ANDAND or_classname_pattern_expr:b {:
                                                                   Grm.parserTrace("classname_pattern_expr && or_classname_pattern_expr");
           RESULT = parser.nf.CPEBinary(parser.pos(a,b),
					a,
					CPEBinary.COND_AND,
					b);
        
                                                                   :};

or_classname_pattern_expr ::=
    unary_classname_pattern_expr:a {:
                                   Grm.parserTrace("or_classname_pattern_expr is a unary_classname_pattern_expr");
           RESULT = a;
        
                                   :}
 |  or_classname_pattern_expr:a PC_OROR unary_classname_pattern_expr:b {:
                                                                       Grm.parserTrace("or_classname_pattern_expr || unary_classname_pattern_expr");
           RESULT = parser.nf.CPEBinary(parser.pos(a,b), a, CPEBinary.COND_OR, b);
        
                                                                       :};

unary_classname_pattern_expr ::=
    basic_classname_pattern:a {:
                              Grm.parserTrace("unary_classname_pattern_expr is a  basic_classname_pattern");
           RESULT = a;
        
                              :}
 |  PC_NOT:x unary_classname_pattern_expr:a {:
                                            Grm.parserTrace("! unary_classname_pattern_expr");
           RESULT = parser.nf.CPENot(parser.pos(x,a),a);
        
                                            :};

basic_classname_pattern ::=
    name_pattern:a {:
                   Grm.parserTrace("classname_type_pattern is a name_pattern");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a));
	   } else {
	       cpe = parser.nf.CPEName(parser.pos(a), a);
	   }
	   RESULT = cpe;
        
                   :}
 |  name_pattern:a PC_PLUS:p {:
                             Grm.parserTrace("classname_type_pattern is name_pattern +");
	   ClassnamePatternExpr cpe;
	   if (a.universal()) {
	       cpe = parser.nf.CPEUniversal(parser.pos(a,p));
	   } else {
	       cpe = parser.nf.CPESubName(parser.pos(a,p), a);
	   }
           RESULT = cpe;
        
                             :}
 |  LPAREN:lp classname_pattern_expr:a RPAREN:rp {:
                                                 Grm.parserTrace("basic_classname_pattern is a ( classname_pattern_expr )");
           RESULT = a;
        
                                                 :};

modifier_pattern_expr ::=
    modifier:a {:
               Grm.parserTrace("first modifier " + a);
          RESULT = new TypedList(new LinkedList(),
				 ModifierPattern.class,
				 false);
	  RESULT.add(parser.nf.ModifierPattern(null,a,true));
       
               :}
 |  PC_NOT:b modifier:a {:
                        Grm.parserTrace("first modifier is NOT " + a);
          RESULT = new TypedList(new LinkedList(),
				 ModifierPattern.class,
				 false);
	  RESULT.add(parser.nf.ModifierPattern(parser.pos(b),a,false));
       
                        :}
 |  modifier_pattern_expr:a modifier:b {:
                                       Grm.parserTrace("another modifier is " + b);
          a.add(parser.nf.ModifierPattern(parser.pos(a),b,true));
          RESULT = a;
       
                                       :}
 |  modifier_pattern_expr:a PC_NOT:c modifier:b {:
                                                Grm.parserTrace("another modifier is NOT" + b);
          a.add(parser.nf.ModifierPattern(parser.pos(c),b,true)); 
          RESULT = a;
       
                                                :};

throws_pattern_expr_opt ::=
    {:
    Grm.parserTrace("no throws pattern");
          RESULT = null;
       
    :}
 |  THROWS classname_pattern_expr:a {:
                                    Grm.parserTrace("has throws pattern");
          RESULT = a;
       
                                    :};

method_constructor_pattern ::=
    method_pattern:a {:
                     Grm.parserTrace("method_constructor is method");
          RESULT = a;
       
                     :}
 |  constructor_pattern:a {:
                          Grm.parserTrace("method_constructor is constructor");
          RESULT = a;
       
                          :};

method_pattern ::=
    modifier_pattern_expr:a type_pattern_expr:b classtype_dot_id:c LPAREN:lp formal_pattern_list_opt:d RPAREN:rp throws_pattern_expr_opt:e {:
                                                                                                                                           Grm.parserTrace("method_pattern with modifiers");
           RESULT = parser.nf.MethodPattern(parser.pos(b,e),a,b,c,d,e);
        
                                                                                                                                           :}
 |  type_pattern_expr:b classtype_dot_id:c LPAREN:lp formal_pattern_list_opt:d RPAREN:rp throws_pattern_expr_opt:e {:
                                                                                                                   Grm.parserTrace("method_pattern no modifiers");
           List mods = new TypedList(new LinkedList(),
                                     ModifierPattern.class,
                                     true);
           RESULT = parser.nf.MethodPattern(parser.pos(b,e),mods,b,c,d,e);
        
                                                                                                                   :};

constructor_pattern ::=
    modifier_pattern_expr:a classtype_dot_new:b LPAREN:lp formal_pattern_list_opt:c RPAREN:rp throws_pattern_expr_opt:d {:
                                                                                                                        Grm.parserTrace("constructor_pattern with modifiers");
           RESULT = parser.nf.ConstructorPattern(parser.pos(b,d),
                                                 a,b,c,d);
        
                                                                                                                        :}
 |  classtype_dot_new:b LPAREN:lp formal_pattern_list_opt:c RPAREN:rp throws_pattern_expr_opt:d {:
                                                                                                Grm.parserTrace("constructor_pattern no modifiers");
	   List mods = new TypedList(new LinkedList(),
                                     ModifierPattern.class,
                                     true);
           RESULT = parser.nf.ConstructorPattern(parser.pos(b,d),mods,b,c,d);
        
                                                                                                :};

field_pattern ::=
    modifier_pattern_expr:a type_pattern_expr:b classtype_dot_id:c {:
                                                                   Grm.parserTrace("field pattern with modifiers");
          RESULT = parser.nf.FieldPattern(parser.pos(b,c),a,b,c);
       
                                                                   :}
 |  type_pattern_expr:b classtype_dot_id:c {:
                                           Grm.parserTrace("field pattern without modifiers");
          List a = new TypedList(new LinkedList(),
			         ModifierPattern.class,
                                 false);
          RESULT = parser.nf.FieldPattern(parser.pos(b,c),a,b,c);
       
                                           :};

formal_pattern_list_opt ::=
    {:
    Grm.parserTrace("Empty formal parameter list"); 
          RESULT = new TypedList(new LinkedList(),
			         FormalPattern.class,
                                 false); 
       
    :}
 |  formal_pattern_list:a {:
                          Grm.parserTrace("Non-empty formal parameter list");
	  RESULT = a; 
       
                          :};

formal_pattern_list ::=
    formal_pattern:a {:
                     Grm.parserTrace("First formal pattern in the list.");
           RESULT = new TypedList(new LinkedList(),
				  FormalPattern.class,
				  false);
	   RESULT.add(a); 
        
                     :}
 |  formal_pattern_list:a COMMA formal_pattern:b {:
                                                 Grm.parserTrace("Another formal parameter");
	   a.add(b);
           RESULT = a;
        
                                                 :};

formal_pattern ::=
    PC_DOTDOT:a {:
                Grm.parserTrace("DOT DOT formal pattern");
            RESULT = parser.nf.DotDotFormalPattern(parser.pos(a));
         
                :}
 |  type_pattern_expr:a {:
                        Grm.parserTrace("A type pattern formal pattern");
            RESULT = parser.nf.TypeFormalPattern(parser.pos(a),a);
         
                        :};

type_id_star_list_opt ::=
    {:
    Grm.parserTrace("Empty pointcut parameter list"); 
          RESULT = new LinkedList();
       
    :}
 |  type_id_star_list:a {:
                        Grm.parserTrace("Non-empty pointcut parameter list");
	  RESULT = a; 
       
                        :};

type_id_star_list ::=
    type_id_star:a {:
                   Grm.parserTrace("First pointcut parameter in the list.");
           RESULT = new LinkedList();
	       RESULT.add(a); 
        
                   :}
 |  type_id_star_list:a COMMA type_id_star:b {:
                                             Grm.parserTrace("Another pointcut parameter");
	   a.add(b);
           RESULT = a;
        
                                             :};

type_id_star ::=
    PC_MULT:a {:
              Grm.parserTrace("Star pointcut parameter");
            RESULT = parser.nf.ArgStar(parser.pos(a));
         
              :}
 |  PC_DOTDOT:a {:
                Grm.parserTrace("DotDot pointcut parameter");
            RESULT = parser.nf.ArgDotDot(parser.pos(a));
         
                :}
 |  type:a {:
           Grm.parserTrace("A type pointcut parameter");
            RESULT =parser.nf.AmbTypeOrLocal(parser.pos(a),a);
         
           :};


